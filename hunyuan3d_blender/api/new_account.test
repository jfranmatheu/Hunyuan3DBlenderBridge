import asyncio
import re
import time
import requests # Although session is handled internally by get_session, requests might be needed elsewhere
from pyppeteer import launch
from typing import Dict, List, Any, Optional

# Assume these imports work based on your project structure
# You might need to adjust the relative paths (.) depending on where you run this script from
try:
    # These will no longer be directly used in automate_hunyuan_login
    # from .tempmail.mailbox import get_temp_mailbox
    # from .tempmail.messages import get_temp_messages
    from .session import get_session
except ImportError:
    print("Warning: Running as script, attempting absolute imports for api functions.")
    # Adjust these imports if the above relative ones fail when running as a script
    # from bl_ext.user_default.hunyuan3d_blender.api.tempmail.mailbox import get_temp_mailbox
    # from bl_ext.user_default.hunyuan3d_blender.api.tempmail.messages import get_temp_messages
    from bl_ext.user_default.hunyuan3d_blender.api.session import get_session


async def automate_hunyuan_login() -> Optional[Dict[str, str]]:
    """
    Automates the Hunyuan 3D login process using a temporary email obtained via browser automation.

    Returns:
        A dictionary containing the relevant 'hy_' cookies if login is successful,
        otherwise None.
    """
    browser = None
    hunyuan_page = None # Renamed from 'page'
    temp_mail_page = None
    email_address = None
    code = None
    hy_cookies_dict = None

    # --- Configuration ---
    hunyuan_url = 'https://3d.hunyuan.tencent.com/'
    temp_mail_url = 'https://temp-mail.org/en/'
    max_message_poll_attempts = 15
    message_poll_interval = 10 # Seconds to wait for messages event after refresh click
    max_email_age_seconds = 70 # Slightly increased, ensure it's reasonable for temp-mail refresh
    # --------------------

    # Variables for temp-mail message interception
    latest_messages_payload = None
    new_messages_event = asyncio.Event()

    async def on_temp_mail_response(response):
        nonlocal latest_messages_payload, new_messages_event
        if "web2.temp-mail.org/messages" in response.url() and response.ok:
            try:
                data = await response.json()
                if data and isinstance(data, dict) and "messages" in data:
                    latest_messages_payload = data
                    new_messages_event.set()
                    # print(f"DEBUG: Intercepted messages: {len(data['messages'])} msgs") # For debugging
            except Exception as e:
                print(f"  Error processing temp-mail messages response: {e}")

    try:
        print("Step 0: Launching browser...")
        
        # Using the confirmed path for Brave Browser
        brave_executable_path = "C:\\Program Files\\BraveSoftware\\Brave-Browser\\Application\\brave.exe"
        
        browser = await launch(
            headless=False, 
            args=['--no-sandbox'],
            executablePath=brave_executable_path
        )

        # Step 1: Get temporary email address via Pyppeteer
        print(f"Step 1: Navigating to {temp_mail_url} to get temporary email...")
        temp_mail_page = await browser.newPage()
        await temp_mail_page.setViewport({'width': 1280, 'height': 800})
        temp_mail_page.on('response', on_temp_mail_response) # Attach listener early

        await temp_mail_page.goto(temp_mail_url, {'waitUntil': 'networkidle0', 'timeout': 60000})
        
        try:
            await temp_mail_page.waitForSelector('input#mail', {'visible': True, 'timeout': 60000}) # Wait for element to exist
            print("  Email input field is visible on temp-mail.org.")

            # Wait until the input value is no longer "Loading..." and looks like an email
            await temp_mail_page.waitForFunction(
                '''
                (selector) => {
                    const emailInput = document.querySelector(selector);
                    if (!emailInput) return false;
                    const emailValue = emailInput.value;
                    return emailValue && !emailValue.toLowerCase().startsWith("loading") && emailValue.includes("@");
                }
                ''',
                {'timeout': 45000}, # Increased timeout for this condition
                'input#mail'
            )
            print("  Email input field value has updated from 'Loading...'.")

            email_input_element = await temp_mail_page.querySelector('input#mail')
            email_address = await temp_mail_page.evaluate('(element) => element.value', email_input_element)
            
            if not email_address or "loading" in email_address.lower() or "@" not in email_address:
                print(f"❌ Failed to get a valid email address. Value obtained: '{email_address}'")
                raise Exception(f"Invalid email obtained: {email_address}")
            print(f"✅ Obtained temporary email from page: {email_address}")
        except Exception as e:
            print(f"❌ Failed to get temporary email address from {temp_mail_url}: {e}")
            await temp_mail_page.screenshot({'path': 'error_step1_get_email.png'})
            return None

        # --- Hunyuan Browser Automation Setup ---
        print("Step 2: Launching Hunyuan page and navigating...")
        hunyuan_page = await browser.newPage()
        await hunyuan_page.setViewport({'width': 1380, 'height': 900})
        await hunyuan_page.goto(hunyuan_url, {'waitUntil': 'networkidle0', 'timeout': 60000})
        print("  Hunyuan page loaded.")
        # --------------------------------

        # Step 2 (Continued): Initiate Login Flow on Hunyuan Page
        print("Step 2: Initiating Hunyuan login...")
        try:
            await hunyuan_page.waitForSelector('.login-btn', {'visible': True, 'timeout': 20000})
            await hunyuan_page.click('.login-btn')
            print("  Clicked Hunyuan login button.")

            # Wait for email login elements to be ready
            # The data-value attribute is literally "'email'" (single quotes inside double quotes in HTML)
            # So the Python string must represent this correctly.
            email_login_selector = "input.t-radio-button__former[data-value=\"'email'\"]"
            await hunyuan_page.waitForSelector(email_login_selector, {'visible': True, 'timeout': 15000})
            print("  Hunyuan email login form loaded.")

            # Add a small delay to ensure the element is fully interactable after being visible
            await asyncio.sleep(5) # 1-second delay

            await hunyuan_page.click(email_login_selector)
            print("  Selected email login type on Hunyuan.")

            await hunyuan_page.waitForSelector("input[type='tel'].t-input__inner", {'visible': True, 'timeout': 15000})
            await hunyuan_page.type("input[type='tel'].t-input__inner", email_address)
            print(f"  Pasted email ({email_address}) into Hunyuan form.")

            await hunyuan_page.waitForSelector('a.hyc-email-login__send-code', {'visible': True})
            await hunyuan_page.click('a.hyc-email-login__send-code')
            print("  Clicked 'Send Code' link on Hunyuan.")

            await hunyuan_page.waitForSelector('.t-dialog__footer button:nth-child(2)', {'visible': True, 'timeout': 10000})
            await hunyuan_page.click('.t-dialog__footer button:nth-child(2)')
            print("  Clicked confirmation button in Hunyuan popup.")

        except Exception as e:
            print(f"❌ Error during Step 2 (Hunyuan Login Initiation): {e}")
            if hunyuan_page: await hunyuan_page.screenshot({'path': 'error_step2_screenshot.png'})
            raise

        # Step 3: Poll for Verification Code using temp_mail_page
        print(f"Step 3: Polling temp-mail.org for verification email (max {max_message_poll_attempts} attempts, {message_poll_interval}s interval)...")
        found_code = False
        for attempt in range(max_message_poll_attempts):
            print(f"  Attempt {attempt + 1}/{max_message_poll_attempts} on temp-mail.org...")
            new_messages_event.clear() # Reset event for this attempt
            
            try:
                # Click refresh on temp-mail page to fetch new messages
                await temp_mail_page.waitForSelector('button#click-to-refresh', {'visible': True, 'timeout': 10000})
                await temp_mail_page.click('button#click-to-refresh')
                print("    Clicked refresh on temp-mail.org.")
                # Wait for the response handler to signal new messages
                await asyncio.wait_for(new_messages_event.wait(), timeout=message_poll_interval)
            except asyncio.TimeoutError:
                print(f"    Timeout waiting for messages response from temp-mail.org after {message_poll_interval}s.")
            except Exception as e:
                print(f"    Error clicking refresh or waiting for new messages event on temp-mail.org: {e}")
                # Potentially take a screenshot of temp_mail_page if useful
                # await temp_mail_page.screenshot({'path': f'error_step3_refresh_attempt_{attempt+1}.png'})

            if latest_messages_payload and "messages" in latest_messages_payload:
                messages_list = latest_messages_payload.get("messages", [])
                now_unix = time.time()
                for msg in reversed(messages_list): # Check newest messages first
                    sender = msg.get("from", "")
                    received_at_raw = msg.get("receivedAt") # This might be a string timestamp or number
                    body = msg.get("bodyPreview", "") # Or "bodyHtml" or "bodyText" if preview isn't enough

                    # Convert received_at to unix timestamp if it's a string (e.g., ISO format)
                    # temp-mail.org's API provides 'receivedAt' as seconds since epoch (number)
                    received_at = None
                    if isinstance(received_at_raw, (int, float)):
                        received_at = float(received_at_raw)
                    # Add more parsing if received_at_raw is a string date format

                    if "hunyuan_playground@tencent.com" in sender:
                        print(f"    Found potential email from {sender} received at {received_at_raw}.")
                        if isinstance(received_at, (int, float)):
                            email_age_seconds = now_unix - received_at
                            if email_age_seconds <= max_email_age_seconds:
                                print("      Email is recent enough.")
                                match = re.search(r'\b(\d{6})\b', body)
                                if match:
                                    code = match.group(1)
                                    print(f"✅ Extracted verification code: {code}")
                                    found_code = True
                                    break # Found code in this message
                            else:
                                print(f"      Email is too old ({email_age_seconds:.0f}s > {max_email_age_seconds}s ago). Discarding.")
                        else:
                            print(f"      Could not determine email age. 'receivedAt' type: {type(received_at_raw)}, value: {received_at_raw}. Discarding message.")
                if found_code:
                    break # Exit polling loop
            else:
                print("    No new messages payload or 'messages' key missing in payload.")

            if not found_code:
                # The wait for messages already happened via asyncio.wait_for,
                # so just continue to the next attempt if code not found.
                # A small delay before next refresh click might be good if attempts are too rapid.
                if attempt < max_message_poll_attempts -1: # Avoid sleep on last attempt
                     print(f"    Code not found yet. Preparing for next attempt...")
                     await asyncio.sleep(2) # Short delay before next forced refresh cycle

        if not found_code:
            print("❌ Failed to retrieve verification code from temp-mail.org within time limit. Aborting.")
            if hunyuan_page: await hunyuan_page.screenshot({'path': 'error_step3_no_code_hunyuan.png'})
            if temp_mail_page: await temp_mail_page.screenshot({'path': 'error_step3_no_code_tempmail.png'})
            return None

        # Step 4: Enter Code and Finalize Login on Hunyuan Page
        print("Step 4: Entering verification code in Hunyuan browser...")
        try:
            await hunyuan_page.waitForSelector("input[type='number'].t-input__inner", {'visible': True, 'timeout': 10000})
            await hunyuan_page.type("input[type='number'].t-input__inner", code)
            print(f"  Entered code ({code}) into Hunyuan form.")

            await hunyuan_page.waitForSelector('button.hyc-email-login__btn', {'visible': True})
            await hunyuan_page.click('button.hyc-email-login__btn')
            print("  Clicked final login button on Hunyuan.")
        except Exception as e:
            print(f"❌ Error during Step 4 (Hunyuan Entering Code / Final Login): {e}")
            if hunyuan_page: await hunyuan_page.screenshot({'path': 'error_step4_screenshot.png'})
            raise

        # Step 5: Wait for login and Extract Cookies from Hunyuan Page
        print("Step 5: Waiting for Hunyuan login to complete and extracting cookies...")
        try:
            await asyncio.sleep(5) # Increased wait for login process/redirects
            print("  Waited for potential Hunyuan login completion.")
            if hunyuan_page: await hunyuan_page.screenshot({'path': 'post_login_screenshot_hunyuan.png'})

            all_cookies = await hunyuan_page.cookies()
            hy_cookies = [c for c in all_cookies if c['name'].startswith('hy_') and ('.tencent.com' in c['domain'] or '3d.hunyuan.tencent.com' in c['domain'])]

            if not hy_cookies:
                print("❌ Failed to find 'hy_' cookies from Hunyuan after login attempt.")
                current_url = hunyuan_page.url
                print(f"  Current Hunyuan URL: {current_url}")
                return None

            print(f"✅ Found {len(hy_cookies)} 'hy_' cookies from Hunyuan:")
            hy_cookies_dict = {}
            for c in hy_cookies:
                print(f"  - Name: {c['name']}, Domain: {c['domain']}, Expires: {c.get('expires', 'Session')}")
                hy_cookies_dict[c['name']] = c['value']

            print("✅ Hunyuan login process appears successful.")
            return hy_cookies_dict

        except Exception as e:
            print(f"❌ Error during Step 5 (Hunyuan Cookie Extraction): {e}")
            if hunyuan_page: await hunyuan_page.screenshot({'path': 'error_step5_screenshot.png'})
            raise

    except Exception as e:
        print(f"💥 An overall error occurred in automate_hunyuan_login: {e}")
        if hunyuan_page and not hunyuan_page.isClosed():
            try: await hunyuan_page.screenshot({'path': 'error_overall_hunyuan_screenshot.png'})
            except Exception as screen_err: print(f"  Could not take Hunyuan error screenshot: {screen_err}")
        if temp_mail_page and not temp_mail_page.isClosed():
            try: await temp_mail_page.screenshot({'path': 'error_overall_tempmail_screenshot.png'})
            except Exception as screen_err: print(f"  Could not take temp-mail error screenshot: {screen_err}")
        return None

    finally:
        if browser:
            print("Closing browser...")
            await browser.close()


def new_account() -> bool:
    session = get_session(create=True)
    if not session:
        print("❌ Failed to get session. Aborting.")
        return False
    print(f"✅ Obtained session: {session}")
    
    print("Starting Hunyuan 3D login automation...")
    # Use asyncio.run() in Python 3.7+
    cookies = asyncio.run(automate_hunyuan_login())

    # Older Python versions might need:
    # loop = asyncio.get_event_loop()
    # cookies = loop.run_until_complete(automate_hunyuan_login())

    if cookies:
        print("\n--- Successfully Retrieved Cookies ---")
        for name, value in cookies.items():
            # Be careful printing tokens/sensitive values in production logs
            print(f"{name}: {value[:10]}...{value[-5:]}" if len(value) > 15 else value)
        session.cookies.update(cookies)
        print("------------------------------------")
        return True
    else:
        print("\nLogin automation failed.")
        return False


# --- Main Execution ---
if __name__ == "__main__":
    new_account()
